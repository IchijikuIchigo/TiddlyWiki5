title: $:/core/macros/CSS
tags: $:/tags/Macro

\procedure actions-compile-palette-filtered(tempPalette,outputTitle)
<!-- Note the join, needed to cope with palette entries containing spaces -->
\function colour(name) [<tempPalette>getindex<name>] :else[[$:/config/DefaultColourMappings/]addsuffix<name>get[text]] :map[subfilter<currentTiddler>join[ ]]
<!-- Make the colour function use the input palette -->
<$list filter="[<tempPalette>indexes[]sort[]]" variable="colour-name">
	<$let colour-filter={{{ [<tempPalette>getindex<colour-name>] }}}>
		<!-- Note the join, needed to cope with palette entries containing spaces -->
		<$action-setfield $tiddler=<<outputTitle>> $index=<<colour-name>> $value={{{ [subfilter<colour-filter>join[ ]] }}}/>
	</$let>
</$list>
\end actions-compile-palette-filtered

\procedure actions-compile-palette-wikified(tempPalette,outputTitle)
<!-- Define our own deeply backwards compatible local versions of the colour macro -->
\define colour(name)
\whitespace trim
<$transclude tiddler=<<tempPalette>> index="$name$">
	<$transclude tiddler="$:/config/DefaultColourMappings/$name$"/>
</$transclude>
\end colour
\define color(name) <<colour $name$>>
<$list filter="[<tempPalette>indexes[]sort[]]" variable="colour-name" $debug="yes">
	<$wikify name="colour-value" text={{{ [<tempPalette>getindex<colour-name>] }}} mode="inline">
		<$action-setfield $tiddler=<<outputTitle>> $index=<<colour-name>> $value=<<colour-value>>/>
	</$wikify>
</$list>
\end actions-compile-palette-wikified

\procedure actions-compile-palette(inputTitle,outputTitle,defaultImport="$:/palettes/Vanilla")
\procedure tv-action-refresh-policy() always
<$let
	tempPalette="$:/temp/palette-consolidated"
>
	<!-- Clear the temporary consolidated palette -->
	<$action-deletetiddler $tiddler=<<tempPalette>>/>
	<!-- Consolidate the imported palette -->
	<$let importTitle={{{ [<inputTitle>get[palette-import]else<defaultImport>] }}}>
		<%if [<importTitle>!match[]] %>
			<$list filter="[<importTitle>indexes[]sort[]]" variable="colour-name">
				<$action-setfield $tiddler=<<tempPalette>> $index=<<colour-name>> $value={{{ [<importTitle>getindex<colour-name>] }}}/>
			</$list>
		<%endif%>
	</$let>
	<!-- Consolidate the main palette -->
	<$list filter="[<inputTitle>indexes[]sort[]]" variable="colour-name">
		<$action-setfield $tiddler=<<tempPalette>> $index=<<colour-name>> $value={{{ [<inputTitle>getindex<colour-name>] }}}/>
	</$list>
	<!-- Compile the temporary palette to the output palette -->
	<%if [<inputTitle>get[palette-type]match[modern]] %>
		<$transclude $variable="actions-compile-palette-filtered" tempPalette=<<tempPalette>> outputTitle=<<outputTitle>>/>
	<%else%>
		<$transclude $variable="actions-compile-palette-wikified" tempPalette=<<tempPalette>> outputTitle=<<outputTitle>>/>
	<%endif%>
	<!-- Remove the temporary consolidated palette -->
	<!-- <$action-deletetiddler $tiddler=<<tempPalette>>/> -->
</$let>
\end actions-compile-palette

\procedure actions-recompile-current-palette()
\procedure tv-action-refresh-policy() always
<$transclude $variable="actions-compile-palette" inputTitle={{$:/palette}} outputTitle="$:/temp/palette-colours"/>
\end actions-recompile-current-palette

\procedure actions-switch-colour-palette(paletteTitle)
\procedure tv-action-refresh-policy() always
<$action-deletetiddler $tiddler="$:/temp/palette-colours"/>
<<actions-recompile-current-palette>>
\end actions-switch-colour-palette

\procedure tv-palette-name() $:/temp/palette-colours

\function colour(name)
[<tv-palette-name>getindex<name>] :else[[$:/config/DefaultColourMappings/]addsuffix<name>get[text]]
\end colour

\function color(name)
[function[colour],<name>]
\end color

\function tf.check-colour-contrast-subfunction()
[function[colour],<paletteEntryA>] [function[colour],<paletteEntryB>] +[colour-contrast:DeltaPhi[]fixed[3]]
\end tf.check-colour-contrast-subfunction

\function tf.check-colour-contrast(paletteEntryA,paletteEntryB,threshold)
[function[tf.check-colour-contrast-subfunction]compare:number:gt<threshold>then[ok]] :else[function[tf.check-colour-contrast-subfunction]addsuffix[: ]addsuffix<paletteEntryA>addsuffix[/]addsuffix<paletteEntryB>addsuffix[ contrast is too low]]
\end tf.check-colour-contrast

\function tf.interpolate-colours(paletteEntryA,paletteEntryB,weight)
[function[colour],<paletteEntryA>] [function[colour],<paletteEntryB>] +[colour-interpolate:oklch<weight>]
\end tf.interpolate-colours

\define box-shadow(shadow)
``
-webkit-box-shadow: $shadow$;
	-moz-box-shadow: $shadow$;
		box-shadow: $shadow$;
``
\end

\define filter(filter)
``
-webkit-filter: $filter$;
	-moz-filter: $filter$;
		filter: $filter$;
``
\end

\define transition(transition)
``
-webkit-transition: $transition$;
	-moz-transition: $transition$;
		transition: $transition$;
``
\end

\define transform-origin(origin)
``
-webkit-transform-origin: $origin$;
	-moz-transform-origin: $origin$;
		transform-origin: $origin$;
``
\end

\define background-linear-gradient(gradient)
``
background-image: linear-gradient($gradient$);
background-image: -o-linear-gradient($gradient$);
background-image: -moz-linear-gradient($gradient$);
background-image: -webkit-linear-gradient($gradient$);
background-image: -ms-linear-gradient($gradient$);
``
\end

\define column-count(columns)
``
-moz-column-count: $columns$;
-webkit-column-count: $columns$;
column-count: $columns$;
``
\end

\procedure datauri(title)
<$macrocall $name="makedatauri" type={{{ [<title>get[type]] }}} text={{{ [<title>get[text]] }}} _canonical_uri={{{ [<title>get[_canonical_uri]] }}}/>
\end

\procedure if-sidebar(text)
<$reveal state="$:/state/sidebar" type="match" text="yes" default="yes"><<text>></$reveal>
\end

\procedure if-no-sidebar(text)
<$reveal state="$:/state/sidebar" type="nomatch" text="yes" default="yes"><<text>></$reveal>
\end

\procedure if-background-attachment(text)
<$reveal state="$:/themes/tiddlywiki/vanilla/settings/backgroundimage" type="nomatch" text=""><<text>></$reveal>
\end
